<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<element name="tk-element">
  <script>
    var DEFAULT_PUBLISH_NAME = 'my-element';
    Polymer.register(this, {
      elementAttributes: {
        name: DEFAULT_PUBLISH_NAME
      },
      defaultSource: '<element name="' + DEFAULT_PUBLISH_NAME + '">' +
        '<template></template>' +
        '<script>Polymer.register(this, {});' +
        '</s' + 'cript>' +
      '</element>',
      update: function() {
        Polymer.marshalNodeReferences.call(this, this);
        Polymer.bindModel.call(this, this);
        // TODO(sorvell): events...
      },
      bindProperty: function(target, name, path) {
        if (name === 'textContent') {
          if (path) {
            target.textContent = ' ';
            target = target.firstChild;
          } else {
            target.firstChild.unbind(name);
          }
        } else {
          target.unbind(name);
          target.removeAttribute(name);
        }
        if (path) {
          target.bind(name, this, path);
        }
      },
      applySource: function(source) {
        this.elementAttributes = parseElementAttributes(source);
        var html = tagInnerHTMLFromSource(source, 'template');
        var script = tagInnerHTMLFromSource(source, 'script').trim();
        // re-define design-element with user source
        var eltSource = '<element name="' + this.localName + 
          '" extends="tk-element">' + '<script>' + script + '</s' + 
          'cript></element>';
        publisher.register(eltSource);
        var de = document.createElement(this.localName);
        de.id = this.id;
        de.elementAttributes = this.elementAttributes;
        de.innerHTML = html;
        // replace self in parent
        var parent = this.parentNode;
        parent.removeChild(this);
        parent.appendChild(de);
        // asynchronously, update styling
        requestAnimationFrame(function() {
          applyStyle(de);
          ensureChildStyling(de);
          de.send('source-applied', de);
        }.bind(this));
        return de;
      }
    });

    var publisher;
    document.addEventListener('WebComponentsReady', function() {
      publisher = document.createElement('tk-publisher');
    })
        
    // round-tripping *from* source
    function parseElementAttributes(source) {
      var attributes = {};
      var match = source.match('<element([^>]*)>');
      if (match) {
        var parts = match[1].split(' ');
        parts.forEach(function(p) {
          var pair = p.trim().split('=');
          if (pair.length == 2) {
            var name = pair[0].trim(), value = pair[1].trim().slice(1, -1);
            attributes[name] = value;
          }
        });
      }
      return attributes;
    }

    function applyStyle(node) {
      var style = node.querySelector('style');
      if (style && style.sheet) {
        applyIdCssRules(style.sheet.cssRules, node, style.sheet);
      }
    }
    
    function applyIdCssRules(rules, root, sheet) {
      for (var i=0, rule; i < rules.length; i++) {
        rule = rules[i];
        if (rule.selectorText.match(/^#[^, ]*$/) && rule.style) {
          var node = root.querySelector(rule.selectorText);
          if (node) {
            node.style.cssText = rule.style.cssText;
          }
        } else if (rule.cssRules) {
          applyIdCssRules(rules.cssRules, root, sheet);
        }
      }
    }
    
    var elementBlackList = ['style'];
    function ensureChildStyling(node) {
      Array.prototype.forEach.call(node.children, function(n) {
        if (elementBlackList.indexOf(n.localName) < 0 && !n.style.position) {
          n.style.position = 'absolute';
          n.style.left = n.style.top = '0px';
          n.id = makeUniqueId(node, n.localName);
        }
      });
    }
    
    function makeUniqueId(node, id, suffix) {
      var uId = id + (suffix || '');
      return node.querySelector('#' + uId) ?
        makeUniqueId(node, id, suffix ? ++suffix : 1) :
        uId;
    }
    
    function tagInnerHTMLFromSource(source, tag) {
      var matches = source.match(regExpForTag(tag));
      if (matches) {
        return matches[1];
      }
      return '';
    }

    function regExpForTag(tag) {
      return new RegExp('<' + tag + '>([\\S\\s]*)<\/' + tag + '>');
    }
  </script>  
</element>

<element name="design-element" extends="tk-element">
  <script>
    Polymer.register(this);
  </script>
</element>