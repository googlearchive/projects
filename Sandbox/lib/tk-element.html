<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<element name="tk-element">
  <script>
    Toolkit.register(this, {
      test: 'Test!!',
      selected: 1,
      elementName: 'user-element',
      elementLabel: 'User Element',
      update: function() {
        Toolkit.marshalNodeReferences.call(this, this);
        Toolkit.bindModel.call(this, this);
        // TODO(sorvell): events...
      },
      publishElement: function() {
        this.register();
        this.createMeta();
      },
      register: function() {
        if (this.sourceInfo) {
          var elt = elementFromHTML(this.sourceInfo.source, 'element');
          this.elementDefinition = new HTMLElementElement(elt);
        }
      },
      createMeta: function() {
        this.meta = document.createElement('tk-meta');
        var tag = this.elementDefinition.getAttribute('name');
        this.meta.id = tag;
        this.meta.label = this.elementLabel;
        var template = document.createElement('template');
        template.innerHTML = '<' + tag + ' style="display: block; width: 400px; ' +
          'height: 300px;"></' + tag + '>';
        this.meta.appendChild(template);
      },
      bindProperty: function(target, name, path) {
        if (name === 'textContent') {
          if (path) {
            target.textContent = ' ';
            target = target.firstChild;
          } else {
            target.firstChild.unbind(name);
          }
        } else {
          target.unbind(name);
          target.removeAttribute(name);
        }
        if (path) {
          target.bind(name, this, path);
        }
      },
      dumpTag: function(dumpTag, indent, tab) {
        // resolve properties to attributes before dumping
        publishPropertiesToAttributes(this);
        var script = this.sourceInfo ? this.sourceInfo.script :
          'Toolkit.register(this);';
        var html = indent + '<element name="' + this.elementName +'">\n' +
          indent + tab + '<template>\n';
        html += indent + dumpStyle(this, indent + tab + tab, tab);
        Array.prototype.forEach.call(this.childNodes, function(c) {
          html += dumpTag(c, indent + tab + tab);
        });
        html += indent + tab + '</template>\n' +
          indent + tab +'<script>\n' +
          indent + tab + tab + script + '\n' +
          indent + tab +'</s' + 'cript>\n'+
          indent + '</element>';
        // remove inline styles
        html = html
          .replace(/ style="[^"]*"/g, '')
          .replace(/( )?selected-element/g, '')
          ;
        return html;
      },
      applySource: function(source) {
        var templateHtml = tagInnerHTMLFromSource(source, 'template');
        this.sourceInfo = {
          source: source,
          style: tagInnerHTMLFromSource(templateHtml,'style'),
          html: templateHtml.replace(regExpForTag('style'), '').trim(),
          script: tagInnerHTMLFromSource(source, 'script').trim()
        }
        //console.log(this.sourceInfo.html);
        this.innerHTML = this.sourceInfo.html;
        this.applyStyle(this.sourceInfo.style);
      },
      styleRe: /(#[^{]*){([^}]*)}/g,
      applyStyle: function(style) {
        var matches, node;
        while (matches = this.styleRe.exec(style)) {
          node = this.querySelector(matches[1].trim());
          if (node) {
            node.style.cssText = matches[2];
          }
        }
      }
    });

    function tagInnerHTMLFromSource(source, tag) {
      var matches = source.match(regExpForTag(tag));
      if (matches) {
        return matches[1];
      }
      return '';
    }

    function regExpForTag(tag) {
      return new RegExp('<' + tag + '>([\\S\\s]*)<\/' + tag + '>');
    }

    function elementFromHTML(html, selector) {
      var d = document.createElement('div');
      d.innerHTML = html;
      return d.querySelector(selector);
    }
    
    function publishPropertiesToAttributes(element) {
      var elt = element && element.firstElementChild;
      while (elt) {
        var p$ = elt.__published;
        if (p$) {
          Object.keys(p$).forEach(function(n) {
            var v = elt[n], binding = Toolkit.getBinding(elt, n);
            if (binding) {
              elt.setAttribute(n, '{{ ' + binding + ' }}');
            } else if (v && (typeof v === 'string' || typeof v === 'number' ||
                typeof v === 'boolean')) {
              /*if (typeof v === 'boolean') {
                v = n;
              }*/
              elt.setAttribute(n, v);
            } else {
              elt.removeAttribute(n);
            }
          });
        }
        publishPropertiesToAttributes(elt);
        elt = elt.nextElementSibling;
      }
    }
    
    function dumpStyle(element, startIndent, tab) {
      var css = startIndent + '<style>\n';
      function subtree(root, indent) {
        var e = root.firstElementChild;
        while (e) {
          var parts = e.hasAttribute('style') ? 
            e.getAttribute('style').split(';') : null;
          if (parts && e.id) {
            css += indent + '#' + e.id + ' {\n';
            parts.forEach(function(p) {
              if (p) {
                css += indent + tab + p.trim() + ';\n';
              }
            });
            css += indent + '}' + '\n';
          }
          if (e.firstElementChild) {
            subtree(e, indent);
          }
          e = e.nextElementSibling;
        }
      }
      subtree(element || this.element, (startIndent || '') + tab);
      css += startIndent + '</style>\n';
      return css;
    }
  </script>  
</element>
