<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<script src="reflection.js"></script>

<element name="tk-inspector" attributes="element">
  <template>
    <style>
      @host {
        * {
          border: 1px solid silver;
        }
      }
      #header {
        background-color: #E0E0E0;
        border-bottom: 1px solid silver;
        padding-top: 4px;
        height: 44px;
        /*line-height: 60px;*/
      }
      #interior {
        position: absolute;
        top: 62px;
        right: 0;
        bottom: 0;
        left: 0;
        padding: 8px;
        overflow-x: hidden;
        overflow-y: auto;
      }
      g-icon-button {
        vertical-align: middle;
      }
    </style>
      <div id="header">
        <g-icon-button src="assets/ic_chevron_left_darkreg.png" on-click="selectParentElement"></g-icon-button>
        <b>{{name}}</b>
        <g-icon-button src="assets/ic_delete_darkreg.png" on-click="deleteElement" style="float: right"></g-icon-button>
      </div>
      <div id="interior">
        <template repeat="{{properties}}">
          <tk-property-editor property="{{}}"></tk-property-editor>
        </template>
        <tk-style-inspector element="{{element}}"></tk-style-inspector>
      </div>
    </div>
  </template>
  <script>
    Toolkit.register(this, {
      element: null,
      properties: null,
      name: '',
      elementChanged: function() {
        this.properties = Reflection.properties(this.element);
        this.name = this.element && this.element.localName || '';
      },
      deleteElement: function() {
        this.send('delete-element');
      },
      selectParentElement: function() {
        this.send('parent-element');
      }
    });
  </script>
</element>

<element name="tk-style-inspector" attributes="element">
  <template>
    <template repeat="{{properties}}">
      <tk-property-editor property="{{}}"></tk-property-editor>
    </template>
    <tk-meta id="meta">
      <property name="backgroundColor" kind="color"></property>
      <property name="opacity" kind="range" min="0" max="1" step="0.1" defaultvalue="1"></property>
      <property name="border"></property>
      <property name="width"></property>
      <property name="height"></property>
    </tk-meta>
  </template>
  <script>
    Toolkit.register(this, {
      properties: null,
      elementChanged: function() {
        this.properties = Reflection.styles(this.element, this.$.meta.properties);
      }
    });
  </script>
</element>

<element name="tk-property-editor" attributes="property">
  <template>
    <style>
      @host {
        *{
          display: block;
          white-space: nowrap;
          margin-bottom: 12px;
        }
      }
      .property-name {
        text-overflow: ellipsis;
        overflow: hidden;
        color: #949494;
        font-size: 0.9rem;
        font-weight: bold;
        margin-bottom: 8px;
      }
    </style>
    <div class="property-name">{{property.name}}:</div>
    <content></content>
  </template>
  <script>
    Toolkit.register(this, {
      property: null,
      editor: null,
      editorTypes: {
        'boolean': 'tk-boolean-property-editor',
        'string': 'tk-string-property-editor',
        'select': 'tk-select-property-editor',
        'color': 'tk-color-property-editor',
        'text': 'tk-text-property-editor',
        'id-select': 'tk-id-select-property-editor',
        'target-select': 'tk-target-select-property-editor',
        'speech': 'tk-speech-property-editor',
        'range': 'tk-range-property-editor',
        any: 'tk-string-property-editor'
      },
      propertyChanged: function() {
        var m = this.property.meta;
        var type = this.editorTypes[m && m.kind || typeof this.property.value];
        this.editor = document.createElement(type || this.editorTypes.any);
        this.editor.property = this.property;
      },
      editorChanged: function(inOld) {
        if (inOld) {
          inOld.parentNode.removeChild(inOld);
        }
        this.appendChild(this.editor);
      }
    });
  </script>
</element>

<element name="tk-abstract-property-editor">
  <script>
    Toolkit.register(this, {
      property: null,
      liveValue: null,
      propertyChanged: function() {
        Toolkit.bindProperties(this, 'liveValue', this.property.obj, 
          this.property.name);
      },
      liveValueChanged: function() {
        if (this.liveValue !== this.property.obj[this.property.name]) {
          this.send('property-changed');
        }
      },
      inputChange: function(e) {
        this.liveValue = e.target.value;
      }
    });
  </script>
</element>

<element name="tk-string-property-editor" extends="tk-abstract-property-editor">
  <template>
    <style>
      input {
        padding: 6px;
        margin-left: 0;
        width: 95%; 
        -webkit-user-select: all; 
        -moz-user-select: all;
        user-select: all;
      }
    </style>
    <input id="input" type="{{type}}" value="{{inputValue}}" on-change="inputChange">
  </template>
  <script>
    // TODO(sorvell): promote to toolkit and integrate with Element.unbind
    Toolkit.unbindProperty = function(inA, inProperty) {
      Object.defineProperty(inA, inProperty, {
        value: inA[inProperty],
        enumerable: true,
        writable: true,
        configurable: true
      });
    }
    
    Toolkit.register(this, {
      type: "text",
      propertyChanged: function() {
        // if bound, the inspector should reflect binding value (attribute),
        // not the property value
        var bindingValue = this.getBindingValue();
        if (bindingValue && bindingValue.match(Toolkit.bindPattern)) {
          this.liveValue = bindingValue;
        } else {
          this.super();
        }
      },
      liveValueChanged: function() {
        if (String(this.liveValue).match(Toolkit.bindPattern)) {
          // unbind inspector from object.
          Toolkit.unbindProperty(this, 'liveValue');
          this.setBindingValue(this.liveValue);
          this.send('property-changed');
        // if there was a binding, unbind object property
        } else {
          var attrValue = this.getBindingValue();
          if (attrValue && attrValue.match(Toolkit.bindPattern)) {
            // unbind... 
            this.property.obj.unbind(this.property.name);
            // TODO(sorvell): remove when element.unbind unbinds correctly 
            // for property bindings
            Toolkit.unbindProperty(this.property.obj, this.property.name);
            // set value ex post facto to handle inability set textContent
            // when unbinding
            this.property.obj[this.property.name] = this.liveValue;
            this.setBindingValue(null);
            // rebind liveValue
            this.propertyChanged();
          }
        }
        this.inputValue = this.liveValue;
        this.super();
      },
      getBindingValue: function() {
        return (this.property.obj.__bindings && 
          this.property.obj.__bindings[this.property.name]) ||
          (this.property.obj.getAttribute && 
          this.property.obj.getAttribute(this.property.name));
      },
      setBindingValue: function(value) {
        this.property.obj.__bindings = this.property.obj.__bindings || {};
        this.property.obj.__bindings[this.property.name] = value;
        if (value) {
          this.property.obj.setAttribute(this.property.name, value);
        } else {
          this.property.obj.removeAttribute(this.property.name);
        }
      }
    });
  </script>
</element>

<element name="tk-color-property-editor" extends="tk-string-property-editor">
  <script>
    Toolkit.register(this, {
      type: 'color',
      ready: function() {
        // TODO(dfreedm): Workaround for http://crbug.com/234801, colorpicker
        // does not update swatch when in shadowdom because of focus issues
        this.$.input.tabindex = -1;
      },
      liveValueChanged: function() {
        this.inputValue = this.toHex(this.liveValue);
      },
      toHex: function(color) {
        if (!color || color.substr(0, 1) === "#") {
          return color;
        }
        var nums = /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/i.exec(color),
            r = parseInt(nums[2], 10).toString(16),
            g = parseInt(nums[3], 10).toString(16),
            b = parseInt(nums[4], 10).toString(16);
        return "#"+ (
            (r.length == 1 ? r + "0" : r) +
            (g.length == 1 ? g + "0" : g) +
            (b.length == 1 ? b + "0" : b)
        );
      }
    });
  </script>
</element>

<element name="tk-boolean-property-editor" extends="tk-abstract-property-editor">
  <template>
    <input type="checkbox" checked="{{liveValue}}"><br/>
  </template>
  <script>
    Toolkit.register(this);
  </script>
</element>

<element name="tk-select-property-editor" extends="tk-abstract-property-editor">
  <template>
    <style>
      select {
        padding: 6px;
        margin-left: 0;
        margin-right: 0;
        width: 95%; 
        -webkit-user-select: all; 
        -moz-user-select: all;
        user-select: all;
      }
    </style>
    <select id="select" on-change="inputChange">
      <template repeat="{{options}}">
        <option>{{}}</option>
      </template>
    </select><br/>
  </template>
  <script>
    Toolkit.register(this, {
      propertyChanged: function() {
        this.options = this.property.meta.options;
        this.super();
        // allow template to generate options before setting value
        this.asyncMethod(function() {
          this.$.select.value = this.liveValue;
        });
      }
    });
  </script>
</element>

<element name="tk-text-property-editor" extends="tk-abstract-property-editor">
  <template>
    <style>
      textarea {
        padding: 6px;
        margin: 0;
        width: 95%; 
        -webkit-user-select: all; 
        -moz-user-select: all;
        user-select: all;
        overflow: auto; 
      }
    </style>
    <textarea id="textarea" on-change="inputChange" Xcols="14" rows="10"></textarea>
  </template>
  <script>
    Toolkit.register(this, {
      propertyChanged: function() {
        this.super();
        this.$.textarea.textContent = this.liveValue;
      }
    });
  </script>
</element>

<element name="tk-range-property-editor" extends="tk-abstract-property-editor">
  <template>
    <style>
      input {
        padding: 6px;
        margin-left: 0;
        width: 95%; 
        -webkit-user-select: all; 
        -moz-user-select: all;
        user-select: all;
      }
    </style>
    <input id="editor" type="range" value="{{liveValue}}" min="{{property.meta.min}}" max="{{property.meta.max}}" step="{{property.meta.step}}"><br/>
  </template>
  <script>
    Toolkit.register(this, {
      liveValueChanged: function() {
        if (this.liveValue === null || this.liveValue === '') {
          this.$.editor.value = this.property.meta.defaultvalue;
        }
      }
    });
  </script>
</element>

<element name="tk-id-select-property-editor" extends="tk-select-property-editor">  
  <script>
    Toolkit.register(this, {
      idPrefix: '',
      propertyChanged: function() {
        var o = [];
        var p = this.property.obj.parentNode;
        while (p.parentNode && p.localName !== 'tk-canvas') {
          p = p.parentNode;
        }
        Array.prototype.forEach.call(p.querySelectorAll('[id]'), function(n) {
          o.push(this.idPrefix + n.id);
        }, this);
        this.property.meta.options = o;
        this.super();
      }
    });
  </script>
</element>

<element name="tk-target-select-property-editor" extends="tk-id-select-property-editor">
  <script>
    Toolkit.register(this, {
      idPrefix: '#'
    });
  </script>
</element>

<element name="tk-speech-property-editor" extends="tk-abstract-property-editor">
  <template>
    <input type="{{type}}" value="{{liveValue}}" style="width: 40%; -webkit-user-select: all; -moz-user-select: all;">
    <speech-mic completeTranscript="{{liveValue}}" style="position: relative; top: 15px; left: -10px;"></speech-mic><br>
  </template>
  <script>
    Toolkit.register(this, {
      type: "text"
    });
  </script>
</element>
